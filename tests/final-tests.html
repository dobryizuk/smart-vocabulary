<!DOCTYPE html>
<html><head><meta charset="UTF-8"><title>Final Tests</title></head><body>
<h2>üß™ Complete Test Suite - All 32 Tests</h2>
<div id="results"></div>
<div id="test-interface" style="display: none; margin: 20px 0; padding: 20px; border: 2px solid #007AFF; border-radius: 12px;"></div>
<script src="../js/app.js"></script>
<script>
let bPassed = 0, bFailed = 0, results = [];

function bTest(name, fn) {
    try {
        fn();
        bPassed++;
        const msg = '‚úÖ ' + name;
        console.log(msg);
        results.push(msg);
    } catch (e) {
        bFailed++;
        const msg = '‚ùå ' + name + ': ' + e.message;
        console.log(msg);
        results.push(msg);
    }
}

function bAssert(condition, message = 'assertion failed') {
    if (!condition) throw new Error(message);
}

function bAssertEqual(actual, expected) {
    if (actual !== expected) throw new Error('expected ' + expected + ', got ' + actual);
}

function bAssertNotNull(value, message = 'Value should not be null') {
    if (value === null || value === undefined) throw new Error(message);
}

function bAssertType(value, expectedType, message = `Expected type ${expectedType}`) {
    if (typeof value !== expectedType) throw new Error(message + `, got ${typeof value}`);
}

// Mock functions
window.renderWordList = () => {};
window.updateStats = () => {};
window.saveUserProgress = () => {};
window.saveAllVocabulary = () => {};

// Additional test functions
function canShowReverseExercise(word) {
    const now = new Date();
    const lastExerciseDate = word.lastExerciseDate ? new Date(word.lastExerciseDate) : null;
    const timeSinceLastExercise = lastExerciseDate ? now - lastExerciseDate : Infinity;
    const minInterval = 10 * 60 * 1000; // 10 minutes
    
    return !lastExerciseDate || 
           word.lastExerciseType !== 'reverse' || 
           timeSinceLastExercise >= minInterval;
}

function determineExerciseType(word) {
    if (!isEligibleForReverseTranslation(word)) {
        return 'regular';
    }
    
    if (!canShowReverseExercise(word)) {
        return 'regular';
    }
    
    return Math.random() < 0.5 ? 'regular' : 'reverse';
}

setTimeout(() => {
    // Enhanced test data
    vocabulary = [
        { 
            id: "test1", 
            english: "beautiful", 
            russian: "–∫—Ä–∞—Å–∏–≤—ã–π", 
            phonetic: "/ÀàbjuÀêt…™f…ôl/",
            definition: "Pleasing the senses or mind aesthetically",
            easeFactor: 2.8,
            repetition: 2,
            reviewHistory: [
                { date: "2025-07-23T10:00:00.000Z", difficulty: "easy", exerciseType: "regular" }
            ],
            lastExerciseType: null,
            lastExerciseDate: null
        },
        { 
            id: "test2", 
            english: "challenge", 
            russian: "–≤—ã–∑–æ–≤", 
            easeFactor: 2.2,
            repetition: 1,
            reviewHistory: [
                { date: "2025-07-23T09:00:00.000Z", difficulty: "hard", exerciseType: "regular" }
            ],
            lastExerciseType: null,
            lastExerciseDate: null
        }
    ];
    userProgress = { "test1": { repetition: 1 }, "test2": { repetition: 0 } };

    // === SECTION 1: CORE FUNCTIONS ===
    bTest('isEligibleForReverseTranslation', () => {
        bAssert(typeof isEligibleForReverseTranslation === 'function');
        bAssert(isEligibleForReverseTranslation(vocabulary[0]) === true);
        bAssert(isEligibleForReverseTranslation(vocabulary[1]) === false);
    });

    bTest('calculateTypingAccuracy', () => {
        bAssert(typeof calculateTypingAccuracy === 'function');
        const result = calculateTypingAccuracy('beautiful', 'beautiful');
        bAssertEqual(result.accuracy, 100);
        bAssertEqual(result.difficulty, 'perfect');
    });

    bTest('calculateLearningProgress', () => {
        bAssert(typeof calculateLearningProgress === 'function');
        const progress = calculateLearningProgress(1.3);
        bAssert(progress >= 0 && progress <= 100);
    });

    bTest('normalizeText', () => {
        bAssert(typeof normalizeText === 'function');
        const result = normalizeText('Hello, World!');
        bAssertEqual(result, 'hello world');
    });

    bTest('levenshteinDistance', () => {
        bAssert(typeof levenshteinDistance === 'function');
        bAssertEqual(levenshteinDistance('hello', 'hello'), 0);
        bAssertEqual(levenshteinDistance('hello', 'helo'), 1);
    });

    // === SECTION 2: LEARNING PROGRESS TESTS ===
    bTest('Learning Progress Calculation - Normal Case', () => {
        bAssert(typeof calculateLearningProgress === 'function');
        const result = calculateLearningProgress(1.3);
        const expected = 0; // Starting easeFactor should give 0% progress
        bAssertEqual(result, expected);
    });

    bTest('Learning Progress Calculation - Edge Cases', () => {
        bAssert(typeof calculateLearningProgress === 'function');
        bAssertEqual(calculateLearningProgress(1.3), 0);
        bAssertEqual(calculateLearningProgress(1.0), 0);
        bAssertEqual(calculateLearningProgress(3.5), 100);
        bAssertEqual(calculateLearningProgress(4.0), 100);
    });



    // === SECTION 5: SESSION SEPARATION TESTS ===
    bTest('canShowReverseExercise - timing logic', () => {
        const testWord = { ...vocabulary[0] };
        
        // Test fresh word (no previous exercise)
        bAssert(canShowReverseExercise(testWord) === true);
        
        // Test recent reverse exercise (5 minutes ago)
        testWord.lastExerciseType = 'reverse';
        testWord.lastExerciseDate = new Date(Date.now() - 5 * 60 * 1000).toISOString();
        bAssert(canShowReverseExercise(testWord) === false);
        
        // Test old reverse exercise (15 minutes ago)
        testWord.lastExerciseDate = new Date(Date.now() - 15 * 60 * 1000).toISOString();
        bAssert(canShowReverseExercise(testWord) === true);
        
        // Test recent regular exercise
        testWord.lastExerciseType = 'regular';
        testWord.lastExerciseDate = new Date(Date.now() - 5 * 60 * 1000).toISOString();
        bAssert(canShowReverseExercise(testWord) === true);
    });

    bTest('determineExerciseType - logic flow', () => {
        // Test ineligible word
        const result1 = determineExerciseType(vocabulary[1]);
        bAssertEqual(result1, 'regular');
        
        // Test eligible word (should return regular or reverse)
        const result2 = determineExerciseType(vocabulary[0]);
        bAssert(['regular', 'reverse'].includes(result2));
    });

    // === SECTION 6: REVERSE TRANSLATION ELIGIBILITY TESTS ===
    bTest('Reverse Translation Eligibility - Word with Easy Review', () => {
        const word = {
            id: "reverse_test_001",
            english: "hello",
            russian: "–ø—Ä–∏–≤–µ—Ç",
            reviewHistory: [
                { date: "2025-07-23T10:00:00.000Z", difficulty: "medium" },
                { date: "2025-07-23T11:00:00.000Z", difficulty: "easy" }
            ]
        };

        const result = isEligibleForReverseTranslation(word);
        bAssert(result === true);
    });

    bTest('Reverse Translation Eligibility - Word with Perfect Review', () => {
        const word = {
            id: "reverse_test_002",
            english: "world",
            russian: "–º–∏—Ä",
            reviewHistory: [
                { date: "2025-07-23T10:00:00.000Z", difficulty: "hard" },
                { date: "2025-07-23T11:00:00.000Z", difficulty: "perfect" }
            ]
        };

        const result = isEligibleForReverseTranslation(word);
        bAssert(result === true);
    });

    bTest('Reverse Translation Eligibility - Word with Only Hard/Medium Reviews', () => {
        const word = {
            id: "reverse_test_003",
            english: "difficult",
            russian: "—Ç—Ä—É–¥–Ω—ã–π",
            reviewHistory: [
                { date: "2025-07-23T10:00:00.000Z", difficulty: "hard" },
                { date: "2025-07-23T11:00:00.000Z", difficulty: "medium" }
            ]
        };

        const result = isEligibleForReverseTranslation(word);
        bAssert(result === false);
    });

    // === SECTION 7: TEXT PROCESSING TESTS ===
    bTest('Text Normalization for Typing Accuracy', () => {
        bAssert(typeof normalizeText === 'function');
        bAssertEqual(normalizeText('Hello!'), 'hello');
        bAssertEqual(normalizeText('  Hello World  '), 'hello world');
        bAssertEqual(normalizeText('Hello,   World!'), 'hello world');
        bAssertEqual(normalizeText('HELLO'), 'hello');
    });

    bTest('Levenshtein Distance Algorithm', () => {
        bAssert(typeof levenshteinDistance === 'function');
        bAssertEqual(levenshteinDistance('hello', 'hello'), 0);
        bAssertEqual(levenshteinDistance('hello', 'helo'), 1);
        bAssertEqual(levenshteinDistance('hello', 'world'), 4);
        bAssertEqual(levenshteinDistance('', 'hello'), 5);
    });

    // === SECTION 8: COMPREHENSIVE ACCURACY TESTS ===
    bTest('typing accuracy - multiple scenarios', () => {
        const testCases = [
            { input: 'beautiful', expected: 'beautiful', minAccuracy: 100 },
            { input: 'beautful', expected: 'beautiful', minAccuracy: 85 },
            { input: 'beutiful', expected: 'beautiful', minAccuracy: 75 },
            { input: 'wrong', expected: 'beautiful', maxAccuracy: 20 }
        ];
        
        testCases.forEach((testCase, i) => {
            const result = calculateTypingAccuracy(testCase.input, testCase.expected);
            if (testCase.minAccuracy) {
                bAssert(result.accuracy >= testCase.minAccuracy, 
                    `Case ${i+1}: "${testCase.input}" should have ‚â•${testCase.minAccuracy}% accuracy, got ${result.accuracy}%`);
            }
            if (testCase.maxAccuracy) {
                bAssert(result.accuracy <= testCase.maxAccuracy, 
                    `Case ${i+1}: "${testCase.input}" should have ‚â§${testCase.maxAccuracy}% accuracy, got ${result.accuracy}%`);
            }
        });
    });

    // === SECTION 9: UI INTEGRATION TESTS ===
    bTest('reverse translation UI creation', () => {
        const interfaceDiv = document.getElementById('test-interface');
        const currentWord = vocabulary[0];
        
        // Create UI
        interfaceDiv.innerHTML = `
            <div class="reverse-translation-card">
                <div class="word-metadata">
                    <span>üîÑ Reverse Translation</span>
                </div>
                <div class="card-word">${currentWord.russian}</div>
                <div class="card-phonetic">${currentWord.phonetic}</div>
                <input type="text" id="reverse-input" placeholder="Type English translation...">
                <div id="reverse-feedback"></div>
                <button id="reverse-check">Check Answer</button>
            </div>
        `;
        interfaceDiv.style.display = 'block';
        
        // Verify elements exist
        bAssertNotNull(document.getElementById('reverse-input'));
        bAssertNotNull(document.getElementById('reverse-feedback'));
        bAssertNotNull(document.getElementById('reverse-check'));
        bAssert(interfaceDiv.innerHTML.includes(currentWord.russian));
        bAssert(interfaceDiv.innerHTML.includes(currentWord.phonetic));
    });

    bTest('real-time input validation', () => {
        const input = document.getElementById('reverse-input');
        const feedback = document.getElementById('reverse-feedback');
        
        if (!input || !feedback) {
            throw new Error('UI elements not found - run UI creation test first');
        }
        
        // Test empty input
        input.value = '';
        bAssertEqual(input.value, '');
        
        // Test partial correct input
        input.value = 'beaut';
        const partialResult = calculateTypingAccuracy(input.value, vocabulary[0].english);
        bAssert(partialResult.accuracy > 0);
        
        // Test perfect input
        input.value = vocabulary[0].english;
        const perfectResult = calculateTypingAccuracy(input.value, vocabulary[0].english);
        bAssertEqual(perfectResult.accuracy, 100);
    });

    // === SECTION 10: PROGRESS TRACKING TESTS ===
    bTest('progress tracking with exercise types', () => {
        const testWord = { ...vocabulary[0] };
        const originalLength = testWord.reviewHistory.length;
        
        // Simulate marking difficulty with exercise type
        testWord.currentExerciseType = 'reverse';
        testWord.reviewHistory.push({
            date: new Date().toISOString(),
            difficulty: 'easy',
            exerciseType: 'reverse'
        });
        
        bAssertEqual(testWord.reviewHistory.length, originalLength + 1);
        const lastReview = testWord.reviewHistory[testWord.reviewHistory.length - 1];
        bAssertEqual(lastReview.exerciseType, 'reverse');
        bAssertEqual(lastReview.difficulty, 'easy');
    });

    bTest('Review History Tracking with Exercise Type', () => {
        // Test that markDifficulty function exists and works properly
        bAssert(typeof markDifficulty === 'function');
        
        // Set up a test word as currentLearningWord with all required properties
        const testWord = {
            id: "history_test_001",
            english: "track",
            russian: "–æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å",
            reviewHistory: [],
            currentExerciseType: 'reverse',
            easeFactor: 1.3,
            repetition: 0,
            nextReview: null
        };
        
        // Set up required globals and DOM elements
        const originalCurrentLearningWord = currentLearningWord;
        const originalLearningSession = learningSession;
        const originalSessionStats = sessionStats;
        
        // Create required DOM elements
        if (!document.getElementById('learningContent')) {
            const div = document.createElement('div');
            div.id = 'learningContent';
            document.body.appendChild(div);
        }
        
        // Set up globals
        currentLearningWord = testWord;
        learningSession = [testWord]; // Prevent endLearningSession from being called
        sessionStats = { total: 0, correct: 0, streak: 0 };
        
        // Verify setup
        bAssert(currentLearningWord === testWord);
        bAssert(currentLearningWord.repetition === 0);
        bAssert(currentLearningWord.easeFactor === 1.3);
        bAssert(typeof SpacedRepetition.calculateNextReview === 'function');
        
        const initialLength = testWord.reviewHistory.length;
        
        try {
            // Use real markDifficulty function
            markDifficulty('easy');
            
            // Verify review was added
            bAssert(testWord.reviewHistory.length === initialLength + 1, 
                `Review history length: expected ${initialLength + 1}, got ${testWord.reviewHistory.length}`);
            const lastReview = testWord.reviewHistory[testWord.reviewHistory.length - 1];
            bAssertEqual(lastReview.difficulty, 'easy', `Expected difficulty 'easy', got '${lastReview.difficulty}'`);
            bAssertEqual(lastReview.exerciseType, 'reverse', `Expected exerciseType 'reverse', got '${lastReview.exerciseType}'`);
            bAssertNotNull(lastReview.date, 'Review date should not be null');
        } finally {
            // Always restore original state
            currentLearningWord = originalCurrentLearningWord;
            learningSession = originalLearningSession;
            sessionStats = originalSessionStats;
        }
    });

    // === SECTION 11: DELETE FUNCTION TEST ===
    bTest('deleteWord function exists and works', () => {
        bAssert(typeof deleteWord === 'function', 'deleteWord function should exist');
        
        // Test with actual vocabulary data
        const testVocab = [
            { id: "delete_test", english: "test", russian: "—Ç–µ—Å—Ç", easeFactor: 1.3, reviewHistory: [] },
            { id: "keep_test", english: "keep", russian: "–æ—Å—Ç–∞–≤–∏—Ç—å", easeFactor: 1.5, reviewHistory: [] }
        ];
        
        // Backup original vocabulary
        const originalVocab = [...vocabulary];
        vocabulary.push(...testVocab);
        
        // Mock confirmation to auto-confirm
        const originalShowDeleteConfirmation = window.showDeleteConfirmation;
        window.showDeleteConfirmation = function(word, onConfirm) {
            onConfirm();
        };
        
        const initialLength = vocabulary.length;
        deleteWord("delete_test");
        
        // Verify deletion worked
        bAssert(vocabulary.length === initialLength - 1, 'Vocabulary length should decrease by 1');
        bAssert(vocabulary.find(w => w.id === "delete_test") === undefined, 'Deleted word should not exist');
        bAssert(vocabulary.find(w => w.id === "keep_test") !== undefined, 'Other words should remain');
        
        // Restore original state
        vocabulary.length = 0;
        vocabulary.push(...originalVocab);
        window.showDeleteConfirmation = originalShowDeleteConfirmation;
    });




    // === SECTION 15: PERFORMANCE TEST ===
    bTest('Large Array Processing Performance', () => {
        const startTime = performance.now();
        
        const largeArray = Array(10000).fill().map((_, i) => ({
            id: `word_${i}`,
            english: `word${i}`,
            russian: `—Å–ª–æ–≤–æ${i}`,
            easeFactor: 1.3
        }));

        const processed = largeArray.filter(item => item.easeFactor >= 1.0);
        const endTime = performance.now();

        bAssertEqual(processed.length, 10000);
        bAssert(endTime - startTime < 1000);
    });

    // === SECTION 16: REAL EXPORT/IMPORT FUNCTION TESTS ===
    bTest('Real createExportData function test', () => {
        bAssert(typeof createExportData === 'function', 'createExportData function should exist');
        
        // Test with real vocabulary data
        const testVocabulary = [
            {
                id: "browser_export_test",
                english: "browser",
                russian: "–±—Ä–∞—É–∑–µ—Ä",
                definition: "A web browser application",
                phonetic: "/Ààbra äz…ôr/",
                easeFactor: 1.7,
                repetition: 3,
                reviewHistory: [
                    { date: "2025-07-25T10:00:00.000Z", difficulty: "easy", exerciseType: "regular" },
                    { date: "2025-07-26T10:00:00.000Z", difficulty: "perfect", exerciseType: "reverse" }
                ],
                addedDate: "2025-07-24T10:00:00.000Z",
                nextReview: "2025-08-05T10:00:00.000Z"
            }
        ];
        
        // Test real export function
        const exportResult = createExportData(testVocabulary);
        
        // Validate export structure
        bAssert(exportResult.vocabulary && Array.isArray(exportResult.vocabulary), 'Export should have vocabulary array');
        bAssert(exportResult.vocabulary.length === 1, 'Export should have correct number of words');
        bAssert(typeof exportResult.exportDate === 'string', 'Export should have exportDate');
        bAssert(typeof exportResult.appVersion === 'string', 'Export should have appVersion');
        bAssert(typeof exportResult.totalWords === 'number', 'Export should have totalWords');
        bAssert(exportResult.userProgress === undefined, 'Export should not have userProgress (single source of truth)');
        
        // Validate exported word structure
        const exportedWord = exportResult.vocabulary[0];
        bAssert(exportedWord.id === "browser_export_test", 'Exported word should preserve id');
        bAssert(exportedWord.english === "browser", 'Exported word should preserve english');
        bAssert(exportedWord.russian === "–±—Ä–∞—É–∑–µ—Ä", 'Exported word should preserve russian');
        bAssert(exportedWord.easeFactor === 1.7, 'Exported word should preserve easeFactor');
        bAssert(exportedWord.repetition === 3, 'Exported word should preserve repetition');
        bAssert(Array.isArray(exportedWord.reviewHistory), 'Exported word should have reviewHistory array');
        bAssert(exportedWord.reviewHistory.length === 2, 'Exported word should preserve reviewHistory');
        
        // Test that exported word works with app functions
        bAssert(isEligibleForReverseTranslation(exportedWord), 'Exported word should work with app functions');
    });
    
    bTest('Real validateAndProcessImportData function test', () => {
        bAssert(typeof validateAndProcessImportData === 'function', 'validateAndProcessImportData function should exist');
        
        // Test with valid import data
        const validImportData = {
            vocabulary: [
                {
                    id: "browser_import_test",
                    english: "import",
                    russian: "–∏–º–ø–æ—Ä—Ç",
                    definition: "To bring data into a system",
                    easeFactor: 1.4,
                    repetition: 1,
                    reviewHistory: [
                        { date: "2025-07-25T10:00:00.000Z", difficulty: "medium", exerciseType: "regular" }
                    ],
                    addedDate: "2025-07-24T10:00:00.000Z"
                }
            ],
            exportDate: "2025-07-28T10:00:00.000Z",
            appVersion: "1.0",
            totalWords: 1
        };
        
        // Test real import validation function
        const validationResult = validateAndProcessImportData(validImportData);
        
        // Validate validation results
        bAssert(validationResult.valid === true, 'Validation should succeed');
        bAssert(validationResult.vocabulary && Array.isArray(validationResult.vocabulary), 'Should return vocabulary array');
        bAssert(validationResult.vocabulary.length === 1, 'Should return correct number of words');
        bAssert(validationResult.totalWords === 1, 'Should return correct total count');
        
        // Test that validated word works with app functions
        const validatedWord = validationResult.vocabulary[0];
        const progress = calculateLearningProgress(validatedWord.easeFactor);
        bAssert(typeof progress === 'number' && progress >= 0 && progress <= 100, 'Validated word should work with progress calculation');
        
        // Test invalid import data
        const invalidDataCases = [
            { name: 'missing vocabulary', data: { totalWords: 0 } },
            { name: 'vocabulary not array', data: { vocabulary: "not array", totalWords: 0 } },
            { name: 'word missing id', data: { vocabulary: [{ english: "test", russian: "—Ç–µ—Å—Ç", easeFactor: 1.3, repetition: 0, reviewHistory: [] }], totalWords: 1 } }
        ];
        
        invalidDataCases.forEach(testCase => {
            try {
                validateAndProcessImportData(testCase.data);
                bAssert(false, `${testCase.name} should throw error`);
            } catch (error) {
                bAssert(error.message.includes('Invalid backup file format') || error.message.includes('Missing or invalid'), `${testCase.name} should throw validation error`);
            }
        });
    });
    
    bTest('Export-Import round trip integrity using real functions', () => {
        // Test round trip using real functions with test data
        const originalVocabulary = [
            {
                id: "roundtrip_browser_test",
                english: "roundtrip",
                russian: "–∫—Ä—É–≥–æ–≤–∞—è –ø–æ–µ–∑–¥–∫–∞",
                definition: "A journey returning to the starting point",
                phonetic: "/Ààra ändtr…™p/",
                easeFactor: 1.9,
                repetition: 5,
                reviewHistory: [
                    { date: "2025-07-20T10:00:00.000Z", difficulty: "hard", exerciseType: "regular" },
                    { date: "2025-07-22T10:00:00.000Z", difficulty: "easy", exerciseType: "reverse" },
                    { date: "2025-07-24T10:00:00.000Z", difficulty: "perfect", exerciseType: "regular" }
                ],
                addedDate: "2025-07-19T10:00:00.000Z",
                nextReview: "2025-08-10T10:00:00.000Z"
            }
        ];
        
        // Step 1: Export using real function
        const exportedData = createExportData(originalVocabulary);
        
        // Step 2: Import using real validation function
        const importedData = validateAndProcessImportData(exportedData);
        
        // Step 3: Verify round trip integrity
        bAssert(importedData.valid === true, 'Round trip validation should succeed');
        bAssert(importedData.vocabulary.length === originalVocabulary.length, 'Round trip should preserve word count');
        
        // Verify word data integrity
        const originalWord = originalVocabulary[0];
        const importedWord = importedData.vocabulary[0];
        
        // Core fields
        bAssertEqual(importedWord.id, originalWord.id);
        bAssertEqual(importedWord.english, originalWord.english);
        bAssertEqual(importedWord.russian, originalWord.russian);
        bAssertEqual(importedWord.definition, originalWord.definition);
        bAssertEqual(importedWord.phonetic, originalWord.phonetic);
        
        // Progress fields
        bAssertEqual(importedWord.easeFactor, originalWord.easeFactor);
        bAssertEqual(importedWord.repetition, originalWord.repetition);
        bAssertEqual(importedWord.nextReview, originalWord.nextReview);
        bAssertEqual(importedWord.addedDate, originalWord.addedDate);
        
        // Review history
        bAssert(Array.isArray(importedWord.reviewHistory), 'Should have reviewHistory array');
        bAssertEqual(importedWord.reviewHistory.length, originalWord.reviewHistory.length);
        
        // Functional integrity - imported word should work with app functions
        const progress = calculateLearningProgress(importedWord.easeFactor);
        bAssert(typeof progress === 'number' && progress >= 0 && progress <= 100, 'Should work with progress calculation after round trip');
        
        bAssert(isEligibleForReverseTranslation(importedWord), 'Should work with reverse translation eligibility after round trip');
    });
    
    bTest('File system and UI integration test', () => {
        // Test that main UI functions exist and are accessible
        bAssert(typeof exportData === 'function', 'exportData UI function should exist');
        bAssert(typeof importData === 'function', 'importData UI function should exist');
        
        // Test that we can access DOM elements that the functions would use
        // Note: We can't test actual file operations in automated tests, but we can verify the functions exist
        
        // Test localStorage access (used by export function)
        try {
            localStorage.setItem('test_export', 'test');
            const retrieved = localStorage.getItem('test_export');
            bAssert(retrieved === 'test', 'localStorage should be accessible for export function');
            localStorage.removeItem('test_export');
        } catch (e) {
            bAssert(false, `localStorage access failed: ${e.message}`);
        }
        
        // Test that global vocabulary variable exists (used by export/import)
        bAssert(typeof vocabulary !== 'undefined', 'Global vocabulary variable should be accessible');
        bAssert(Array.isArray(vocabulary), 'Global vocabulary should be an array');
        
        // Test that user progress functions exist
        bAssert(typeof saveUserProgress === 'function', 'saveUserProgress function should exist');
        bAssert(typeof saveAllVocabulary === 'function', 'saveAllVocabulary function should exist');
    });
    
    // === SECTION 17: END-TO-END INTEGRATION TEST ===
    bTest('end-to-end reverse translation workflow', () => {
        // Use fresh word object to avoid test interference
        const word = { 
            id: "e2e_test", 
            english: "beautiful", 
            russian: "–∫—Ä–∞—Å–∏–≤—ã–π", 
            phonetic: "/ÀàbjuÀêt…™f…ôl/",
            definition: "Pleasing the senses or mind aesthetically",
            easeFactor: 2.8,
            repetition: 2,
            reviewHistory: [
                { date: "2025-07-23T10:00:00.000Z", difficulty: "easy", exerciseType: "regular" }
            ],
            lastExerciseType: null,
            lastExerciseDate: null
        };
        
        // Step 1: Check eligibility
        bAssert(typeof isEligibleForReverseTranslation === 'function', 'isEligibleForReverseTranslation function not found');
        console.log('word.reviewHistory:', JSON.stringify(word.reviewHistory));
        const eligible = isEligibleForReverseTranslation(word);
        bAssert(eligible === true, `Step 1 failed: expected eligible=true, got ${eligible} for reviewHistory: ${JSON.stringify(word.reviewHistory)}`);
        
        // Step 2: Check session separation
        const canShow = canShowReverseExercise(word);
        bAssert(canShow === true, `Step 2 failed: expected canShow=true, got ${canShow}`);
        
        // Step 3: Determine exercise type
        const exerciseType = determineExerciseType(word);
        bAssert(['regular', 'reverse'].includes(exerciseType), `Step 3 failed: invalid exerciseType=${exerciseType}`);
        
        // Step 4: Test typing accuracy
        const accuracy = calculateTypingAccuracy('beautiful', word.english);
        bAssert(accuracy.accuracy === 100, `Step 4 failed: expected accuracy=100, got ${accuracy.accuracy} for word.english="${word.english}"`);
        
        // Step 5: Update progress
        word.currentExerciseType = exerciseType;
        const originalHistoryLength = word.reviewHistory.length;
        word.reviewHistory.push({
            date: new Date().toISOString(),
            difficulty: accuracy.difficulty,
            exerciseType: exerciseType
        });
        bAssert(word.reviewHistory.length === originalHistoryLength + 1, `Step 5 failed: history length didn't increase`);
    });

    // === SECTION 18: PWA FUNCTIONALITY TESTS ===
    bTest('Service Worker support', () => {
        bAssert('serviceWorker' in navigator, 'Service Worker API should be available');
    });
    
    bTest('Manifest availability', async () => {
        try {
            const response = await fetch('../manifest.json');
            bAssert(response.ok, 'Manifest file should be accessible');
            const manifest = await response.json();
            bAssert(manifest.name && manifest.short_name, 'Manifest should have required fields');
            bAssert(manifest.icons && manifest.icons.length > 0, 'Manifest should have icons');
        } catch (error) {
            bAssert(false, `Manifest test failed: ${error.message}`);
        }
    });
    
    bTest('PWA detection', () => {
        const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
        console.log('PWA standalone mode:', isStandalone);
        bAssert(true, isStandalone ? 'Running as PWA' : 'Running in browser');
    });
    
    bTest('Local Storage functionality', () => {
        try {
            localStorage.setItem('pwa-test', 'test-value');
            const value = localStorage.getItem('pwa-test');
            bAssert(value === 'test-value', 'localStorage should work correctly');
            localStorage.removeItem('pwa-test');
        } catch (error) {
            bAssert(false, `localStorage test failed: ${error.message}`);
        }
    });
    
    bTest('Cache API support', () => {
        bAssert('caches' in window, 'Cache API should be available for PWA offline functionality');
    });

    // Generate comprehensive results
    setTimeout(() => {
        const total = bPassed + bFailed;
        const successRate = Math.round((bPassed / total) * 100);
        const status = bFailed === 0 ? 'ALL_PASSED' : 'SOME_FAILED';
        const timestamp = new Date().toISOString();
        
        const report = [
            '=== FINAL TESTS RESULTS (ALL 27 TESTS) ===',
            'Timestamp: ' + timestamp,
            'Passed: ' + bPassed + '/' + total + ' (' + successRate + '%)',
            'Status: ' + status,
            '',
            '=== COMPREHENSIVE TEST COVERAGE ===',
            '‚úÖ Core Functions (5 tests)',
            '‚úÖ Learning Progress (2 tests)',
            '‚úÖ Session Logic (2 tests)',
            '‚úÖ Reverse Translation Eligibility (3 tests)',
            '‚úÖ Text Processing (2 tests)',
            '‚úÖ Typing Accuracy (1 comprehensive test)',
            '‚úÖ UI Integration (2 tests)',
            '‚úÖ Progress Tracking (2 tests)',
            '‚úÖ Delete Function (1 test)',
            '‚úÖ Real Export/Import Functions (4 tests)',
            '‚úÖ Performance (1 test)',
            '‚úÖ End-to-End Integration (1 test)',
            '',
            '=== INDIVIDUAL RESULTS ==='
        ].concat(results).join('\n') + '\n\n=== END FINAL REPORT ===';
        
        // Display on page
        document.getElementById('results').innerHTML = '<pre style="background: #f8f9fa; padding: 20px; border-radius: 8px; border: 1px solid #e9ecef; font-size: 12px; max-height: 600px; overflow-y: auto;">' + report + '</pre>';
        document.title = status + '_' + bPassed + '_' + total;
        
        console.log('\n' + report);
        
        // Save results with detailed test info
        const resultData = {
            timestamp: timestamp,
            passed: bPassed,
            failed: bFailed,
            total: total,
            success: bFailed === 0,
            coverage: [
                'Core Functions', 'Learning Progress', 'Session Logic', 
                'Reverse Translation Eligibility', 'Text Processing', 'Typing Accuracy', 
                'UI Integration', 'Progress Tracking', 'Delete Function', 'Performance', 
                'End-to-End Integration'
            ],
            report: report,
            detailedResults: results,
            failedTests: results.filter(r => r.startsWith('‚ùå')),
            passedTests: results.filter(r => r.startsWith('‚úÖ'))
        };
        
        // Store detailed results in multiple places for Node.js to access
        localStorage.setItem('detailedTestResults', JSON.stringify(resultData));
        
        // Also put failed tests in the page title for easy extraction
        const failedTestsInfo = resultData.failedTests.length > 0 ? 
            '|FAILED:' + resultData.failedTests.join('||') : '';
        document.title = status + '_' + bPassed + '_' + total + failedTestsInfo;
        
        // Try WebKit bridge methods
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.testResults) {
            try {
                window.webkit.messageHandlers.testResults.postMessage(resultData);
                console.log('‚úÖ Results sent via webkit.messageHandlers');
            } catch (e) {
                console.log('‚ùå webkit.messageHandlers failed:', e.message);
            }
        }
        
        // Mobile URL scheme only
        if (navigator.userAgent.includes('Mobile')) {
            try {
                const dataUri = 'testresults://save?data=' + encodeURIComponent(JSON.stringify(resultData));
                window.location.href = dataUri;
                setTimeout(() => {
                    console.log('‚úÖ Results sent via custom URL scheme');
                }, 100);
            } catch (e) {
                console.log('‚ùå Custom URL scheme failed:', e.message);
            }
        } else {
            console.log('‚è≠Ô∏è Skipping custom URL scheme (desktop Safari)');
        }
        
        // Fallback storage
        document.body.setAttribute('data-test-results', JSON.stringify(resultData));
        localStorage.setItem('finalTestResults', JSON.stringify(resultData));
        console.log('‚úÖ Results saved to document body and localStorage');
        
    }, 500);
}, 1000);
</script>
</body></html>